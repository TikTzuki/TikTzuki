# SECP256k1

## Overview

**secp256k1** is a Koblitz curve defined over a 256-bit prime field, widely used in Bitcoin, Ethereum, and other cryptocurrencies for digital signatures.

:::info Quick Facts
- **Type**: Koblitz elliptic curve
- **Field**: 256-bit prime field
- **Primary Use**: ECDSA digital signatures in blockchain
- **Security**: Based on the Elliptic Curve Discrete Logarithm Problem (ECDLP)
:::

---

## 1. The Curve Equation

The secp256k1 curve follows this simple equation:

$$
y^2 \equiv x^3 + 7 \ (\text{mod } p)
$$

### Key Parameters

<details>
<summary><strong>Prime Modulus (p)</strong> - Click to expand</summary>

```
p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F
```

In decimal form:

$$
p = 2^{256} - 2^{32} - 2^{9} - 2^{8} - 2^{7} - 2^{6} - 2^{4} - 1
$$

This special form allows for efficient modular arithmetic operations.

</details>

<details>
<summary><strong>Curve Parameters</strong></summary>

$$
a = 0, \quad b = 7
$$

The simplicity of these parameters (especially $a = 0$) makes point addition calculations more efficient.

</details>

<details>
<summary><strong>Generator Point (G)</strong></summary>

The base point used for all key generation:

```
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
```

</details>

<details>
<summary><strong>Order of G (n)</strong></summary>

The number of points generated by repeated addition of G:

```
n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141
  = 115792089237316195423570985008687907852837564279074904382605163141518161494337
```

</details>

:::note Mathematical Operations
All operations (addition, scalar multiplication) are performed **modulo p** on the curve.
:::

---

## 2. Cryptographic Keys

### Private Key (d)

A randomly generated integer in the range `[1, n-1]`.

```
d âˆˆ [1, n-1]
```

:::caution Security Warning
- **Never reuse** or share your private key
- Generate it using a cryptographically secure random number generator
- Store it securely (hardware wallets, encrypted storage)
:::

### Public Key (Q)

Derived from the private key through scalar multiplication:

$$
Q = d \times G
$$

Where $G$ is the generator point and $\times$ represents elliptic curve point multiplication.

:::tip Why It's Secure
The **Elliptic Curve Discrete Logarithm Problem (ECDLP)** makes it computationally infeasible to derive the private key $d$ from the public key $Q$, even though the reverse operation is trivial.
:::

---

## 3. Digital Signature Algorithm (ECDSA)

### Signing Process

To create a signature for message `m`:

1. **Hash the message**:
   ```
   z = SHA256(m)
   ```

2. **Generate a random nonce** `k`:
   ```
   k âˆˆ [1, n-1]
   ```
   :::danger Critical
   The nonce `k` must be:
   - Truly random
   - **Never reused** across signatures
   - Kept secret (nonce reuse or leakage reveals the private key!)
   :::

3. **Compute point** `R`:
   ```
   R = k Â· G
   r = R.x mod n
   ```
   If `r = 0`, choose a new `k` and retry.

4. **Calculate signature component** `s`:
   $$
   s = k^{-1}(z + r \cdot d) \ (\text{mod } n)
   $$
   If `s = 0`, choose a new `k` and retry.

5. **Output signature**:
   ```
   signature = (r, s)
   ```

---

## 4. Signature Verification

Given signature `(r, s)`, public key `Q`, and message `m`:

1. **Verify bounds**:
   ```
   r, s âˆˆ [1, n-1]
   ```

2. **Hash the message**:
   ```
   z = SHA256(m)
   ```

3. **Compute modular inverse**:
   ```
   w = s^{-1} mod n
   ```

4. **Calculate verification parameters**:
   ```
   u1 = z Â· w mod n
   u2 = r Â· w mod n
   ```

5. **Compute verification point**:
   ```
   X = u1Â·G + u2Â·Q
   ```

6. **Verify**:
   - If `X = âˆž` (point at infinity), **reject**
   - If `X.x mod n == r`, signature is **valid** âœ“
   - Otherwise, signature is **invalid** âœ—

:::info Why This Works
The verification process essentially reconstructs the point `R` used during signing, without knowing the private key or nonce.
:::

---

## 5. Python Implementation

You don't need to implement elliptic curve math from scratch. The [`ecdsa`](https://pypi.org/project/ecdsa/) library provides a complete implementation.

### Installation

```bash
pip install ecdsa
```

### Complete Example

```python title="secp256k1_example.py"
from ecdsa import SigningKey, SECP256k1
import hashlib

# Generate a new key pair
sk = SigningKey.generate(curve=SECP256k1)  # private key
vk = sk.verifying_key  # public key

print(f"Private key: {sk.to_string().hex()}")
print(f"Public key (compressed): {vk.to_string('compressed').hex()}")
print()

# Message to sign
message = b"Hello, secp256k1!"
print("SIGNING")
print(f"Message: {message.decode()}")

# Hash and sign
z = hashlib.sha256(message).digest()
signature = sk.sign(z)
print(f"Message hash: {z.hex()}")
print(f"Signature: {signature.hex()}")
print()

# Verify signature
print("VERIFICATION")
try:
    is_valid = vk.verify(signature, z)
    print(f"Signature valid: {is_valid}")
except:
    print("Signature valid: False")
```

### Example Output

```bash
KEY GENERATION
Private key: 4b8d7c3f2e1a9b5d8c6f4a2b1e9d7c5a3f1b9d7e5c3a1f8b6d4c2a1e9d7c5a
Public key (compressed): 0298e4c7f5b8a3d2c1f9e6d4b2a1c9f7e5d3b1a9f8e6d4c2b1a9f7e5d3bcf4

SIGNING
Message: Hello, secp256k1!
Message hash: 8c3d9e5f7b2a4c6d8e1f3a5b7c9d1e3f5a7b9c1d3e5f7a9b1c3d5e7f9a1b3c5d
Signature: 3045022100ab3c5d7e9f1a2b4c6d8e0f2a4c6d8e0f1a3b5c7d9e1f3a5b7c9d0221...

VERIFICATION
Signature valid: True
```

---

## 6. Real-World Applications

### ðŸª™ Cryptocurrency Wallets

<div style={{padding: '20px', backgroundColor: '#f5f5f5', borderRadius: '8px', marginBottom: '20px'}}>

**Bitcoin & Ethereum Architecture:**

1. **Private key** (`d`) â†’ kept secret in your wallet
2. **Public key** (`Q = dÂ·G`) â†’ derived from private key
3. **Address** â†’ hash of public key (visible on blockchain)
4. **Transactions** â†’ signed with ECDSA using secp256k1

```
Private Key â†’ Public Key â†’ Hash â†’ Address
    (d)         (Q = dÂ·G)    (SHA256)  (visible)
```

</div>

### ðŸ”— Blockchain Consensus

- **Transaction Validation**: Nodes verify signatures to ensure transactions are authorized
- **Message Authentication**: Proves that messages come from the holder of the private key
- **Non-repudiation**: Signers cannot deny creating valid signatures

---

:::tip Best Practices

âœ“ Use established libraries (don't roll your own crypto)
âœ“ Generate keys from high-entropy sources
âœ“ Implement proper key rotation policies
âœ“ Use deterministic nonce generation (RFC 6979)
âœ“ Validate all inputs during verification

:::

---

## Further Reading

- [SEC 2: Recommended Elliptic Curve Domain Parameters](https://www.secg.org/sec2-v2.pdf)
- [RFC 6979: Deterministic Usage of DSA and ECDSA](https://tools.ietf.org/html/rfc6979)
- [Bitcoin Developer Guide - Transactions](https://developer.bitcoin.org/devguide/transactions.html)
- [Mastering Bitcoin by Andreas Antonopoulos](https://github.com/bitcoinbook/bitcoinbook)

---

<div style={{textAlign: 'center', padding: '20px', color: '#666'}}>
  <em>Last updated: October 2025</em>
</div>

